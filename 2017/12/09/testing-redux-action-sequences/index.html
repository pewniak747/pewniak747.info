<!DOCTYPE html>
<html>
<head>
<meta charset='utf-8'>
<meta content='IE=edge;chrome=1' http-equiv='X-UA-Compatible'>
<meta content='width=device-width, initial-scale=1.0, viewport-fit=cover' name='viewport'>
<link href='/feed.xml' rel='alternate' title="Tomasz Pewiński's blog" type='application/rss+xml'>
<link href='/favicon.ico' rel='shortcut icon'>
<link href='http://fonts.googleapis.com/css?family=Inconsolata' rel='stylesheet' type='text/css'>
<link href='/stylesheets/syntax.css' rel='stylesheet' type='text/css'>
<link href='/stylesheets/style.css' rel='stylesheet' type='text/css'>
<title>Testing redux action sequences | Tomasz Pewiński</title>
<script>
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-27002819-3']);
  _gaq.push(['_trackPageview']);
  
  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>

</head>
<body>
<header class='site-header--collapsed'>
<div class='container'>
<a href='/'>
<h1 class='site-header__title'>Tomasz Pewinski</h1>
</a>
<nav class='navigation'>
<ul class='navigation__items'>
<li class='navigation__item'>
<a href='/about'>about me</a>
</li>
<li class='navigation__item'>
<a href='/feed.xml'>rss</a>
</li>
<li class='navigation__item'>
<a href='https://twitter.com/pewniak747' target='_blank'>twitter</a>
</li>
<li class='navigation__item'>
<a href='https://github.com/pewniak747' target='_blank'>github</a>
</li>
<li class='navigation__item'>
<a href='https://linkedin.com/pub/tomasz-pewiński/70/955/94' target='_blank'>linkedin</a>
</li>
</ul>
</nav>
</div>
</header>
<section class='container'>
<article class='article'>
<section class='article-header'>
<h1 class='article-header__title'>
<a href='/2017/12/09/testing-redux-action-sequences/'>Testing redux action sequences</a>
</h1>
<time class='article-header__date' pubdate=''> 9 Dec 2017</time>
</section>
<section class='article-content'><p>Testing the features implemented with redux (actions, reducers) is conceptually quite easy. This is due to redux&rsquo; simplicity. Actions are plain objects, and reducers are pure functions that accept everything they need as arguments. There&rsquo;s no need to mock the external world.</p>

<p>On the other hand, a lot of small unit tests are required to fully test an impact of every action and state transition. That could deter from writing them in the first place.</p>

<p>I think that we developers should harness redux&rsquo; simplicity to write better tests. I want to share two approaches I use for more complete redux coverage, especially when dealing with action sequences.</p>

<h2>Setup</h2>

<p>Let&rsquo;s have an obligatory <code>counter</code> reducer as an example.
The possible actions should be incrementing and decrementing the counter.</p>
<pre class="highlight javascript"><code><span class="c1">// Constants</span>
<span class="kr">const</span> <span class="nx">INCREMENT</span> <span class="o">=</span> <span class="s2">"counter/INCREMENT"</span><span class="p">;</span>
<span class="kr">const</span> <span class="nx">DECREMENT</span> <span class="o">=</span> <span class="s2">"counter/DECREMENT"</span><span class="p">;</span>

<span class="c1">// Action creators</span>
<span class="kr">const</span> <span class="nx">increment</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">({</span> <span class="na">type</span><span class="p">:</span> <span class="nx">INCREMENT</span> <span class="p">});</span>
<span class="kr">const</span> <span class="nx">decrement</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">({</span> <span class="na">type</span><span class="p">:</span> <span class="nx">DECREMENT</span> <span class="p">});</span>

<span class="c1">// Reducer</span>
<span class="kr">const</span> <span class="nx">initialState</span> <span class="o">=</span> <span class="p">{</span> <span class="na">count</span><span class="p">:</span> <span class="mi">0</span> <span class="p">};</span>
<span class="kd">function</span> <span class="nx">counter</span><span class="p">(</span><span class="nx">state</span> <span class="o">=</span> <span class="nx">initialState</span><span class="p">,</span> <span class="nx">action</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">switch</span><span class="p">(</span><span class="nx">action</span><span class="p">.</span><span class="nx">type</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">case</span> <span class="nx">INCREMENT</span><span class="p">:</span>
      <span class="k">return</span> <span class="p">{</span> <span class="p">...</span><span class="nx">state</span><span class="p">,</span> <span class="na">count</span><span class="p">:</span> <span class="nx">state</span><span class="p">.</span><span class="nx">count</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">};</span>
    <span class="k">case</span> <span class="nx">DECREMENT</span><span class="p">:</span>
      <span class="k">return</span> <span class="p">{</span> <span class="p">...</span><span class="nx">state</span><span class="p">,</span> <span class="na">count</span><span class="p">:</span> <span class="nx">state</span><span class="p">.</span><span class="nx">count</span> <span class="o">-</span> <span class="mi">1</span> <span class="p">};</span>
    <span class="nl">default</span><span class="p">:</span>
      <span class="k">return</span> <span class="nx">state</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>The most basic tests of this reducer would have a simple structure: given an initial state and an action, the resulting state should be equal to the expected state:</p>
<pre class="highlight javascript"><code><span class="kr">const</span> <span class="nx">initialState</span> <span class="o">=</span> <span class="p">{</span> <span class="na">count</span><span class="p">:</span> <span class="mi">3</span> <span class="p">};</span>
<span class="kr">const</span> <span class="nx">action</span> <span class="o">=</span> <span class="nx">increment</span><span class="p">();</span>
<span class="kr">const</span> <span class="nx">expectedState</span> <span class="o">=</span> <span class="p">{</span> <span class="na">count</span><span class="p">:</span> <span class="mi">4</span> <span class="p">};</span>

<span class="nx">expect</span><span class="p">(</span><span class="nx">counter</span><span class="p">(</span><span class="nx">initialState</span><span class="p">,</span> <span class="nx">action</span><span class="p">)).</span><span class="nx">toEqual</span><span class="p">(</span><span class="nx">expectedState</span><span class="p">);</span>
</code></pre>
<p>Tests of this kind are very useful, but they quickly become repetitive and too numerous, because we only test one state / action at a time.</p>

<p>So, here are a few more ways that we can test a sequence of actions.</p>

<h2>Reducing a sequence of actions to single state</h2>

<p>One kind of a useful reducer test is the one that asserts what the state is after a sequence of actions has been processed (for example, incrementing twice and decrementing once).</p>

<p>Here&rsquo;s what it may look like: it defines an initial state and invokes the reducer with intermediate states and every action in turn.
At the end, it assert that the state is correct.</p>
<pre class="highlight javascript"><code><span class="kr">const</span> <span class="nx">initialState</span> <span class="o">=</span> <span class="p">{</span> <span class="na">count</span><span class="p">:</span> <span class="mi">0</span> <span class="p">};</span>
<span class="kr">const</span> <span class="nx">state1</span> <span class="o">=</span> <span class="nx">counter</span><span class="p">(</span><span class="nx">initialState</span><span class="p">,</span> <span class="nx">increment</span><span class="p">());</span>
<span class="kr">const</span> <span class="nx">state2</span> <span class="o">=</span> <span class="nx">counter</span><span class="p">(</span><span class="nx">state1</span><span class="p">,</span> <span class="nx">increment</span><span class="p">());</span>
<span class="kr">const</span> <span class="nx">state3</span> <span class="o">=</span> <span class="nx">counter</span><span class="p">(</span><span class="nx">state2</span><span class="p">,</span> <span class="nx">decrement</span><span class="p">());</span>
<span class="nx">expect</span><span class="p">(</span><span class="nx">state3</span><span class="p">).</span><span class="nx">toEqual</span><span class="p">({</span> <span class="na">count</span><span class="p">:</span> <span class="mi">1</span> <span class="p">});</span>
</code></pre>
<p>Notice the explicit variables for the intermediate states. This approach gets very tedious when testing long sequences of actions.</p>

<p>Luckily, we can rewrite that test using the <code>Array.prototype.reduce</code> function. This function iterates over an array, passing an accumulator variable (the state) and array item (an action) to another function.
This function would be our <code>counter</code> reducer. The <code>reducer</code> naming in redux is no coincidence, as it&rsquo;s directly inspired by <code>Array.prototype.reduce</code>!</p>
<pre class="highlight javascript"><code><span class="kr">const</span> <span class="nx">initialState</span> <span class="o">=</span> <span class="p">{</span> <span class="na">count</span><span class="p">:</span> <span class="mi">0</span> <span class="p">};</span>
<span class="kr">const</span> <span class="nx">actions</span> <span class="o">=</span> <span class="p">[</span><span class="nx">increment</span><span class="p">(),</span> <span class="nx">increment</span><span class="p">(),</span> <span class="nx">decrement</span><span class="p">()];</span>
<span class="kr">const</span> <span class="nx">expectedState</span> <span class="o">=</span> <span class="p">{</span> <span class="na">count</span><span class="p">:</span> <span class="mi">1</span> <span class="p">};</span>

<span class="nx">expect</span><span class="p">(</span><span class="nx">actions</span><span class="p">.</span><span class="nx">reduce</span><span class="p">(</span><span class="nx">counter</span><span class="p">,</span> <span class="nx">initialState</span><span class="p">)).</span><span class="nx">toEqual</span><span class="p">(</span><span class="nx">expectedState</span><span class="p">);</span>
</code></pre>
<p>The intermediate variables are gone and the test looks much cleaner, as well as is more extendable for longer action sequences.</p>

<p>Bonus point 1: if the <code>Array.prototype.reduce</code> version is not readable enough, I recommend creating a small helper function, e.g. <code>reduceState</code>.</p>
<pre class="highlight javascript"><code><span class="c1">// testHelpers.js</span>
<span class="kd">function</span> <span class="nx">reduceState</span><span class="p">(</span><span class="nx">reducer</span><span class="p">,</span> <span class="nx">initialState</span><span class="p">,</span> <span class="nx">actions</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">actions</span><span class="p">.</span><span class="nx">reduce</span><span class="p">(</span><span class="nx">reducer</span><span class="p">,</span> <span class="nx">initialState</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// counter.test.js</span>
<span class="nx">expect</span><span class="p">(</span><span class="nx">reduceState</span><span class="p">(</span><span class="nx">counter</span><span class="p">,</span> <span class="nx">initialState</span><span class="p">,</span> <span class="nx">actions</span><span class="p">)).</span><span class="nx">toEqual</span><span class="p">(</span><span class="nx">expectedState</span><span class="p">);</span>
</code></pre>
<p>If you&rsquo;re using the excellent functional utility library <a href="http://ramdajs.com">Ramda</a>, its <a href="http://ramdajs.com/docs/#reduce">reduce</a> function does exactly that as well:</p>
<pre class="highlight javascript"><code><span class="kr">import</span> <span class="nx">R</span> <span class="nx">from</span> <span class="s2">"ramda"</span><span class="p">;</span>

<span class="kr">const</span> <span class="nx">reduceState</span> <span class="o">=</span> <span class="nx">R</span><span class="p">.</span><span class="nx">reduce</span><span class="p">;</span>
</code></pre>
<p>Bonus point 2: so far the examples haven&rsquo;t imported the redux library code at all. But, we can also rewrite the previous test by instantiating the store with our small reducer. This is a bit more verbose, but could be useful as well.</p>
<pre class="highlight javascript"><code><span class="kr">import</span> <span class="p">{</span> <span class="nx">createStore</span> <span class="p">}</span> <span class="nx">from</span> <span class="s2">"redux"</span><span class="p">;</span>

<span class="kr">const</span> <span class="nx">initialState</span> <span class="o">=</span> <span class="p">{</span> <span class="na">count</span><span class="p">:</span> <span class="mi">0</span> <span class="p">};</span>
<span class="kr">const</span> <span class="nx">store</span> <span class="o">=</span> <span class="nx">createStore</span><span class="p">(</span><span class="nx">counter</span><span class="p">,</span> <span class="nx">initialState</span><span class="p">);</span>
<span class="nx">store</span><span class="p">.</span><span class="nx">dispatch</span><span class="p">(</span><span class="nx">increment</span><span class="p">());</span>
<span class="nx">store</span><span class="p">.</span><span class="nx">dispatch</span><span class="p">(</span><span class="nx">increment</span><span class="p">());</span>
<span class="nx">store</span><span class="p">.</span><span class="nx">dispatch</span><span class="p">(</span><span class="nx">decrement</span><span class="p">());</span>
<span class="nx">expect</span><span class="p">(</span><span class="nx">store</span><span class="p">.</span><span class="nx">getState</span><span class="p">()).</span><span class="nx">toEqual</span><span class="p">({</span> <span class="na">count</span><span class="p">:</span> <span class="mi">1</span> <span class="p">});</span>
</code></pre>
<h2>Accumulating state while reducing</h2>

<p>Another type of test is also concerned with a sequence of actions, but it asserts correct state at every step, not only at the end.
This way we can have more granular expectations about how the state changes.</p>
<pre class="highlight javascript"><code><span class="kr">const</span> <span class="nx">initialState</span> <span class="o">=</span> <span class="p">{</span> <span class="na">count</span><span class="p">:</span> <span class="mi">0</span> <span class="p">};</span>
<span class="kr">const</span> <span class="nx">state1</span> <span class="o">=</span> <span class="nx">counter</span><span class="p">(</span><span class="nx">initialState</span><span class="p">,</span> <span class="nx">increment</span><span class="p">());</span>
<span class="nx">expect</span><span class="p">(</span><span class="nx">state1</span><span class="p">).</span><span class="nx">toEqual</span><span class="p">({</span> <span class="na">count</span><span class="p">:</span> <span class="mi">1</span> <span class="p">});</span>
<span class="kr">const</span> <span class="nx">state2</span> <span class="o">=</span> <span class="nx">counter</span><span class="p">(</span><span class="nx">state1</span><span class="p">,</span> <span class="nx">increment</span><span class="p">());</span>
<span class="nx">expect</span><span class="p">(</span><span class="nx">state2</span><span class="p">).</span><span class="nx">toEqual</span><span class="p">({</span> <span class="na">count</span><span class="p">:</span> <span class="mi">2</span> <span class="p">});</span>
<span class="kr">const</span> <span class="nx">state3</span> <span class="o">=</span> <span class="nx">counter</span><span class="p">(</span><span class="nx">state2</span><span class="p">,</span> <span class="nx">decrement</span><span class="p">());</span>
<span class="nx">expect</span><span class="p">(</span><span class="nx">state3</span><span class="p">).</span><span class="nx">toEqual</span><span class="p">({</span> <span class="na">count</span><span class="p">:</span> <span class="mi">1</span> <span class="p">});</span>
</code></pre>
<p>There&rsquo;s a way of making this test more succinct; however, it requires a small helper, not present in the core language like <code>Array.prototype.reduce</code>.
This helper will accept a reducer, initial state and array of actions, and return an array of states, beginning from the initial, through intemediate, and ending in the final state.</p>

<p>Let&rsquo;s call it <code>accumulateState</code>:</p>
<pre class="highlight javascript"><code><span class="kd">function</span> <span class="nx">accumulateState</span><span class="p">(</span><span class="nx">reducer</span><span class="p">,</span> <span class="nx">initialState</span><span class="p">,</span> <span class="nx">actions</span><span class="p">)</span> <span class="p">{</span>
  <span class="kr">const</span> <span class="nx">result</span> <span class="o">=</span> <span class="p">[</span><span class="nx">initialState</span><span class="p">];</span>
  <span class="nx">actions</span><span class="p">.</span><span class="nx">forEach</span><span class="p">((</span><span class="nx">action</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="kr">const</span> <span class="nx">currentState</span> <span class="o">=</span> <span class="nx">result</span><span class="p">[</span><span class="nx">result</span><span class="p">.</span><span class="nx">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
    <span class="kr">const</span> <span class="nx">nextState</span> <span class="o">=</span> <span class="nx">reducer</span><span class="p">(</span><span class="nx">currentState</span><span class="p">,</span> <span class="nx">action</span><span class="p">);</span>
    <span class="nx">result</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">nextState</span><span class="p">);</span>
  <span class="p">});</span>
  <span class="k">return</span> <span class="nx">result</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
<p>Using the helper method, the test looks like this:</p>
<pre class="highlight javascript"><code><span class="kr">const</span> <span class="nx">initialState</span> <span class="o">=</span> <span class="p">{</span> <span class="na">count</span><span class="p">:</span> <span class="mi">0</span> <span class="p">};</span>
<span class="kr">const</span> <span class="nx">actions</span> <span class="o">=</span> <span class="p">[</span><span class="nx">increment</span><span class="p">(),</span> <span class="nx">increment</span><span class="p">(),</span> <span class="nx">decrement</span><span class="p">()];</span>
<span class="kr">const</span> <span class="nx">expectedStates</span> <span class="o">=</span> <span class="p">[{</span> <span class="na">count</span><span class="p">:</span> <span class="mi">0</span> <span class="p">},</span> <span class="p">{</span> <span class="na">count</span><span class="p">:</span> <span class="mi">1</span> <span class="p">},</span> <span class="p">{</span> <span class="na">count</span><span class="p">:</span> <span class="mi">2</span> <span class="p">},</span> <span class="p">{</span> <span class="na">count</span><span class="p">:</span> <span class="mi">1</span> <span class="p">}];</span>

<span class="nx">expect</span><span class="p">(</span><span class="nx">accumulateState</span><span class="p">(</span><span class="nx">counter</span><span class="p">,</span> <span class="nx">initialState</span><span class="p">,</span> <span class="nx">actions</span><span class="p">)).</span><span class="nx">toEqual</span><span class="p">(</span><span class="nx">expectedStates</span><span class="p">);</span>
</code></pre>
<p>Bonus point 1: this approach works great with <a href="https://facebook.github.io/jest">jest</a> and <a href="https://facebook.github.io/jest/docs/en/snapshot-testing.html">snapshot testing</a>. The expected states array can be conveniently captured as a snapshot:</p>
<pre class="highlight javascript"><code><span class="kr">const</span> <span class="nx">initialState</span> <span class="o">=</span> <span class="p">{</span> <span class="na">count</span><span class="p">:</span> <span class="mi">0</span> <span class="p">};</span>
<span class="kr">const</span> <span class="nx">actions</span> <span class="o">=</span> <span class="p">[</span><span class="nx">increment</span><span class="p">(),</span> <span class="nx">increment</span><span class="p">(),</span> <span class="nx">decrement</span><span class="p">()];</span>
<span class="nx">expect</span><span class="p">(</span><span class="nx">accumulateState</span><span class="p">(</span><span class="nx">counter</span><span class="p">,</span> <span class="nx">initialState</span><span class="p">,</span> <span class="nx">actions</span><span class="p">)).</span><span class="nx">toMatchSnapshot</span><span class="p">();</span>
</code></pre>
<p>Bonus point 2: if you&rsquo;re using <a href="http://ramdajs.com">Ramda</a>, there&rsquo;s no need to implement a helper - Ramda already has a function that has this exact behaviour.
It&rsquo;s called <a href="http://ramdajs.com/docs/#scan">scan</a>.</p>
<pre class="highlight javascript"><code><span class="kr">import</span> <span class="nx">R</span> <span class="nx">from</span> <span class="s2">"ramda"</span><span class="p">;</span>

<span class="kr">const</span> <span class="nx">accumulateState</span> <span class="o">=</span> <span class="nx">R</span><span class="p">.</span><span class="nx">scan</span><span class="p">;</span>
</code></pre>
<p>Bonus point 3: analogously, the store version would look like this:</p>
<pre class="highlight javascript"><code><span class="kr">import</span> <span class="p">{</span> <span class="nx">createStore</span> <span class="p">}</span> <span class="nx">from</span> <span class="s2">"redux"</span><span class="p">;</span>

<span class="kr">const</span> <span class="nx">initialState</span> <span class="o">=</span> <span class="p">{</span> <span class="na">count</span><span class="p">:</span> <span class="mi">0</span> <span class="p">};</span>
<span class="kr">const</span> <span class="nx">store</span> <span class="o">=</span> <span class="nx">createStore</span><span class="p">(</span><span class="nx">counter</span><span class="p">,</span> <span class="nx">initialState</span><span class="p">);</span>
<span class="nx">store</span><span class="p">.</span><span class="nx">dispatch</span><span class="p">(</span><span class="nx">increment</span><span class="p">());</span>
<span class="nx">expect</span><span class="p">(</span><span class="nx">store</span><span class="p">.</span><span class="nx">getState</span><span class="p">()).</span><span class="nx">toEqual</span><span class="p">({</span> <span class="na">count</span><span class="p">:</span> <span class="mi">1</span> <span class="p">});</span>
<span class="nx">store</span><span class="p">.</span><span class="nx">dispatch</span><span class="p">(</span><span class="nx">increment</span><span class="p">());</span>
<span class="nx">expect</span><span class="p">(</span><span class="nx">store</span><span class="p">.</span><span class="nx">getState</span><span class="p">()).</span><span class="nx">toEqual</span><span class="p">({</span> <span class="na">count</span><span class="p">:</span> <span class="mi">2</span> <span class="p">});</span>
<span class="nx">store</span><span class="p">.</span><span class="nx">dispatch</span><span class="p">(</span><span class="nx">decrement</span><span class="p">());</span>
<span class="nx">expect</span><span class="p">(</span><span class="nx">store</span><span class="p">.</span><span class="nx">getState</span><span class="p">()).</span><span class="nx">toEqual</span><span class="p">({</span> <span class="na">count</span><span class="p">:</span> <span class="mi">1</span> <span class="p">});</span>
</code></pre>
<h2>Summary</h2>

<p>In this article, I introduced two little utility functions for testing redux reducers: <code>reduceState</code> and <code>accumulateState</code>. These fuctions should aid in testing long sequences of actions. For me, these tests also feel more concrete: we&rsquo;re testing how the state changes during the entire interaction, not only one transition at a time.</p>

<p>A word of clarification: in my examples, I used the action creators (<code>increment</code>, <code>decrement</code>) instead of plain object actions. This way, the reducer and action creators are tested &ldquo;together&rdquo; in a single test. I think that&rsquo;s fine; in fact, it gives me more confidence that the two will work together correctly in a real application. I tend not to write unit tests for action creators alone (unless they contain some tricky logic, but that&rsquo;s very rare).</p>

<p>I hope these techniques are useful. What other approaches do you use in your tests? Let me know in the comments!</p>
</section>
<section class='article-comments'><div id='disqus_thread'></div>
<script>
  /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
  var disqus_shortname = 'pewniak747-info'; // required: replace example with your forum shortname
  
  /* * * DON'T EDIT BELOW THIS LINE * * */
  (function() {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>
<noscript>
Please enable JavaScript to view the
<a href='http://disqus.com/?ref_noscript'>comments powered by Disqus.</a>
</noscript>
<a class='dsq-brlink' href='http://disqus.com'>
comments powered by
<span class='logo-disqus'>Disqus</span>
</a>
</section>
</article>

</section>
</body>
</html>
